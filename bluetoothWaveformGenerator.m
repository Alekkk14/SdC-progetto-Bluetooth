function txWaveform = bluetoothWaveformGenerator(data,cfgFormat)
%bluetoothWaveformGenerator Generate Bluetooth BR/EDR PHY waveform
%
%   TXWAVEFORM = bluetoothWaveformGenerator(DATA,CFGFORMAT) generates
%   waveform, a multipacket time-domain Bluetooth basic rate/enhanced data
%   rate (BR/EDR) waveform, for input information bits, DATA, and a given
%   format configuration, CFGFORMAT.
%
%   TXWAVEFORM is a complex column vector containing the generated
%   waveform. It is appended with zero samples to accommodate packet
%   specific slot duration.
%
%   DATA is the information bits representing multiple concatenated
%   payloads. It is a binary column vector of type double. The length of
%   data must be an exact multiple of payload length derived from <a
%   href="matlab:help('bluetoothWaveformConfig.getPayloadLength')">getPayloadLength</a>
%   method.
%
%   CFGFORMAT is a format configuration object of type <a
%   href="matlab:help('bluetoothWaveformConfig')">bluetoothWaveformConfig</a>
%   used to configure the Bluetooth waveform generator.
%
%   % Examples:
%
%   % Example 1:
%   % Generate a time domain signal, for 10 HV1 packets.
%
%   numPackets = 10;
%
%   % Create Bluetooth waveform configuration object
%   cfg = bluetoothWaveformConfig;
%   cfg.PacketType = 'HV1';
%
%   % Create bit vector containing concatenated payloads
%   numBits = getPayloadLength(cfg)*8*numPackets; % Byte to bit conversion
%   dataBits = randi([0 1],numBits,1);
%
%   txWaveform = bluetoothWaveformGenerator(dataBits,cfg);
%   symbolRate = 1e6; % In MHz
%   scope = spectrumAnalyzer;
%   scope.SampleRate = cfg.SamplesPerSymbol*symbolRate;
%   scope(txWaveform);
%
%   % Example 2:
%   % Generate waveform for single enhanced data rate packet, 2-EV3. Here
%   % 2-EV3 packet can be generated by providing packet type as EV3 and
%   % mode as EDR2M.
%
%   % Create Bluetooth waveform configuration object
%   cfg = bluetoothWaveformConfig;
%   cfg.Mode = 'EDR2M';
%   cfg.PacketType = 'EV3';
%
%   % Create bit vector
%   numBits = getPayloadLength(cfg)*8; % Byte to bit conversion
%   dataBits = randi([0 1],numBits,1);
%
%   txWaveform = bluetoothWaveformGenerator(dataBits,cfg);
%
%   See also bluetoothWaveformConfig, bluetoothPhyConfig,
%   bluetoothIdealReceiver, bleWaveformGenerator.

%   Copyright 2019-2024 The Mathworks, Inc.

%#codegen

% Check the number of input arguments
narginchk(2,2);

% Validate the format configuration object
validateattributes(cfgFormat,{'bluetoothWaveformConfig'},{'scalar'},'bluetoothWaveformConfig','cfgFormat',2);
packetType = validateConfig(cfgFormat);

% Initialize packet parameters
phyMode = cfgFormat.Mode;
sps = cfgFormat.SamplesPerSymbol;

% Number of bits in a payload for a single packet (convert bytes to bits)
byte2bit = 8;
numPayloadBits = getPayloadLength(cfgFormat)*byte2bit;

% Validate data bits
if any(strcmp(packetType,{'ID','NULL','POLL'}))
    % No payload for 'ID', 'NULL' and 'POLL' packets
    if ~isempty(data)
        coder.internal.warning('bluetooth:bluetoothWaveformGenerator:EmptyPacket',packetType)
    end
    numPkts = 1;
elseif any(strcmp(packetType,{'DM1','DH1','DM3','DH3','DM5','DH5','2-DH1',...
        '2-DH3','2-DH5','3-DH1','3-DH3','3-DH5'}))
    validateattributes(data,{'numeric','logical'},{'nonnan','finite','binary'},...
        mfilename,'Data');
    emptyInvalid = isempty(data) && numPayloadBits ~= 0 || ...
        ~isempty(data) && numPayloadBits == 0;
    coder.internal.errorIf(~iscolumn(data) || emptyInvalid,'bluetooth:bluetoothWaveformGenerator:ValidPayloadDim');
    if isempty(data) && numPayloadBits == 0
        numPkts = 1;
    else
        numPkts = length(data)/numPayloadBits; % Number of packets
    end
    coder.internal.errorIf(mod(numPkts,1)~=0,...
        'bluetooth:bluetoothWaveformGenerator:PayloadLengthMultiple',numPayloadBits,length(data));
else
    validateattributes(data,{'numeric','logical'},{'nonempty','nonnan','finite',...
        'column','binary'},mfilename,'Data');
    numPkts = length(data)/numPayloadBits; % Number of packets
    coder.internal.errorIf(mod(numPkts,1)~=0,...
        'bluetooth:bluetoothWaveformGenerator:PayloadLengthMultiple',numPayloadBits,length(data));
end

% Extract Bluetooth lower address and higher address part from Bluetooth
% device address
btDeviceAddr = coder.const(int2bit(hex2dec(cfgFormat.DeviceAddress),48,false));
btUAP = btDeviceAddr(25:32); % Bluetooth upper address part
btLAP = btDeviceAddr(1:24); % Bluetooth lower address part

% Parameters specific to EDR2M and EDR3M modes
if ~strcmp(phyMode,'BR')
    guard = complex(zeros(5*sps,1)); % Guard time within the packet
    if strcmp(phyMode,'EDR2M')
        M = 4; % Modulation order
        syncSequence = [0 0 0 1 1 1 0 1 1 1 0 1 1 1 1 1 0 1 0 1 0 1]'; % Synchronization sequence
        trailer = zeros(4,1); % EDR trailer
    else
        M = 8;
        syncSequence = [0 0 0 0 1 0 1 1 1 0 1 0 1 1 1 0 1 0 1 1 1 1 1 1 0 1 0 0 1 0 0 1 0]';
        trailer = zeros(6,1);
    end
    % Generate raised cosine filter coefficients
    rolloff = 0.4;
    span = 8; % To meet the spectral mask requirements
    filtCoeff = rcosdesign(rolloff,span,sps,'sqrt');
end

% Generate access code
accessCode = bluetooth.internal.accessCodeGenerate(btLAP,packetType);

% Generate packet header
header = generatePacketHeader(packetType,phyMode,cfgFormat.LogicalTransportAddress,cfgFormat.HeaderControlBits,flip(btUAP));

% Define a vector of total transmitter waveform length
if any(strcmp(packetType,{'ID','NULL','POLL','FHS','HV1','HV2','HV3','DV','EV3','DM1','DH1','AUX1'}))
    maxSlotSymbols = 625; % Single slot
elseif any(strcmp(packetType,{'EV4','EV5','DM3','DH3'}))
    maxSlotSymbols = 625*3; % Three slots
else % For DM5 and DH5 packets
    maxSlotSymbols = 625*5; % Five slots
end

if isa(data,'single')
    castedRef = single(1);
else
    castedRef = 1;
end

txWaveform = complex(zeros(maxSlotSymbols*numPkts*sps,1,'like',castedRef));
persistent whiten
% Loop over number of packets
for iPkt = 1:numPkts
    % Extract payload for the current packet
    idx = mod((iPkt-1)*numPayloadBits+(0:numPayloadBits-1).',length(data))+1;
    dataPacket = data(idx);

    % Construct payload
    payload = bluetooth.internal.payloadGenerate(logical(dataPacket),packetType,cfgFormat);
    payloadCast = cast(payload,'like',castedRef);

    % Perform data whitening on header and payload, if present
    headerLen = length(header);
    whitenInData = [header; payloadCast];

    if strcmp(cfgFormat.WhitenStatus,'On') && ~strcmp(packetType,'ID')
        if isempty(coder.target)
            if isempty(whiten)
                whiten = bluetoothWhiten("InitialConditionsSource","Input port");
            end
            whitenOutData = whiten(whitenInData,cfgFormat.WhitenInitialization);
            reset(whiten);
        else
            cgWhiten = bluetoothWhiten("InitialConditionsSource","Input port");
            whitenOutData = cgWhiten(whitenInData,cfgFormat.WhitenInitialization);
            reset(cgWhiten);
        end
    else
        whitenOutData = whitenInData;
    end
    headerWhiten = whitenOutData(1:headerLen);
    payloadWhiten = whitenOutData(headerLen+1:end);

    % Perform FEC on payload and header, if present
    payloadFEC = bluetooth.internal.fecEncode(payloadWhiten,packetType);
    headerFEC = repelem(headerWhiten,3);

    % Generate baseband waveform
    if strcmp(phyMode,'BR')
        pdu = [accessCode;headerFEC;payloadFEC]; % Basic rate packet
        waveform = gfskmod(pdu,sps,cfgFormat.ModulationIndex);
    else % For EDR2M and EDR3M modes
        % Perform GFSK modulation on access code and header
        accessCodeHeader = [accessCode;headerFEC];
        ahWaveform = gfskmod(accessCodeHeader,sps,cfgFormat.ModulationIndex);

        % Perform PSK modulation based on the packet type
        if any(strcmp(packetType,{'ID','NULL','POLL'}))
            waveform = ahWaveform; % No payload for ID, NULL and POLL packets
        else
            edrPacket = [syncSequence;payloadFEC;trailer];
            % If the length of EDR packet is not an integer multiple of
            % log2(ModulationOrder), the last symbol of the sequence can be
            % formed by appending data zeros to the appropriate length.
            k = log2(M);
            remPacket = rem(length(edrPacket),k);
            if remPacket~=0
                edrPacketPadded = [edrPacket;zeros(k-remPacket,1,'like',edrPacket)];
            else
                edrPacketPadded = edrPacket;
            end
            % Convert bits to symbols
            edrSym =  bit2int(edrPacketPadded,k);
            if strcmp(phyMode,'EDR2M')
                pskWaveform = dpskmod(edrSym,M,pi/4,'gray'); % Perform pi/4-DQPSK
            else
                pskWaveform = dpskmod(edrSym,M,0,'gray'); % Perform 8-DPSK
            end
            pskWaveformPadded = [pskWaveform;zeros(span,1,'like',pskWaveform)]; % To accommodate filter delay
            txFilt = upfirdn(pskWaveformPadded,filtCoeff,sps); % Perform raised cosine filtering
            txFiltWaveform = txFilt(1:length(pskWaveformPadded)*sps); % Remove filter states
            txFiltAvg = txFiltWaveform/sqrt(var(txFiltWaveform)); % Normalize the filtered waveform
            waveform = [ahWaveform;guard;txFiltAvg];
        end
    end
    % Construct entire waveform
    txWaveform((iPkt-1)*(maxSlotSymbols*sps)+(1:length(waveform))) = waveform;
end
end

% Generate packet header
function header =  generatePacketHeader(packetType,phyMode,ltAddress,hcBits,hecInit)
%generatePacketHeader Generate packet header
%   HEADER =
%   generatePacketHeader(PACKETTYPE,PHYMODE,LTADDRESS,HCBITS,HECINIT)
%   generates packet header based on packet type, mode, logical transport
%   address, header control bits and HEC initialization.

if strcmp(packetType,'ID')
    header = zeros(0,1); % No packet header for ID packet
else % Derive type field based on the packet type and mode
    switch packetType
        case 'POLL'
            type = [0;0;0;1];
        case 'FHS'
            type = [0;0;1;0];
        case 'DM1'
            type = [0;0;1;1];
        case {'DH1','DV'}
            type = [0;1;0;0];
            if (strcmp(phyMode,'EDR3M') || strcmp(packetType,'DV'))
                type = [1;0;0;0];
            end
        case 'HV1'
            type = [0;1;0;1];
        case {'HV2','EV3'}
            if (strcmp(phyMode,'EDR2M') && strcmp(packetType,'EV3')) || strcmp(packetType,'HV2')
                type = [0;1;1;0];
            else
                type = [0;1;1;1];
            end
        case 'HV3'
            type = [0;1;1;1];
        case 'AUX1'
            type = [1;0;0;1];
        case {'DM3','DH3'}
            type = [1;0;1;0];
            if strcmp(packetType,'DH3') && ~strcmp(phyMode,'EDR2M')
                type = [1;0;1;1];
            end
        case {'EV4','EV5'}
            type = [1;1;0;0];
            if any(strcmp(phyMode,{'BR','EDR3M'})) && strcmp(packetType,'EV5')
                type = [1;1;0;1];
            end
        case {'DM5','DH5'}
            type = [1;1;1;0];
            if any(strcmp(phyMode,{'BR','EDR3M'})) && strcmp(packetType,'DH5')
                type = [1;1;1;1];
            end
        otherwise % 'NULL'
            type = [0;0;0;0];
    end
    % Construct header
    headerWithoutHEC = [flip(ltAddress);flip(type);hcBits];
    header = appendHEC(headerWithoutHEC,hecInit); % Perform HEC
end

% Create and configure the CRC and HEC System objects
    function dataOut = appendHEC(dataIn,regInit)
        %appendHEC Generate HEC and append it to the given input
        % DATAOUT = appendHEC(DATAIN,REGINIT) returns the output data, DATAOUT, by
        % generating HEC and appending it to the given input data, DATAIN. REGINIT
        % is the shift register initialization value.
        persistent hecGen
        if isempty(coder.target) % For simulation path, create System object only once
            if isempty(hecGen)
                hecGen = createHECSystemObject(regInit);
            else
                if any(hecGen.InitialConditions ~= regInit)
                    release(hecGen)
                    hecGen.InitialConditions = regInit;
                end
            end
            dataOut = hecGen(dataIn);
        else % For codegen path, create System object each time while generating mex
            sysObjCodegen = createHECSystemObject(regInit);
            dataOut = sysObjCodegen(dataIn);
        end

        function sysObj = createHECSystemObject(regInit)
            %createHECSystemObject Create HEC System object
            % SYSOBJ = createHECSystemObject(REGINIT) creates HEC System object.
            % REGINIT is the shift register initialization value.
            sysObj = comm.CRCGenerator('Polynomial','z^8 + z^7 + z^5 + z^2 + z + 1',...
                'InitialConditions',regInit,'DirectMethod',true);
        end
    end
end

% Create and configure the GFSK modulation System object
function dataOut = gfskmod(dataIn,sps,modIndex)
%gfskmod Gaussian frequency shift keying modulation
% DATAOUT = gfskmod(DATAIN,SPS,MODINDEX) modulates the input data, DATAIN,
% using Gaussian frequency shift keying (GFSK) modulation. SPS denotes the
% number of samples per symbol and MODINDEX denotes the modulation index.
persistent gfskModObj
if isempty(coder.target) % For simulation path create System object only once
    if isempty(gfskModObj)
        gfskModObj = comm.CPMModulator('ModulationOrder',2,'FrequencyPulse','Gaussian',...
            'BandwidthTimeProduct',0.5,'ModulationIndex',modIndex,...
            'BitInput',true,'SamplesPerSymbol',sps);
    else
        release(gfskModObj)
        if gfskModObj.ModulationIndex ~= modIndex || gfskModObj.SamplesPerSymbol ~= sps
            gfskModObj.ModulationIndex = modIndex;
            gfskModObj.SamplesPerSymbol = sps;
        end
    end
    dataOut = gfskModObj(dataIn);
else % For codegen path create System object each time while generating mex
    gfskModCodgen = comm.CPMModulator('ModulationOrder',2,'FrequencyPulse','Gaussian',...
        'BandwidthTimeProduct',0.5,'ModulationIndex',modIndex,...
        'BitInput',true,'SamplesPerSymbol',sps);
    dataOut = gfskModCodgen(dataIn);
end
end